# -*- coding: utf-8 -*-
"""Unsupervised_Learning_The_Heritage_Foundation's_Economic_Freedom_Index_2019_ Analysis_By_David_Salako.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nnHFUU2XQBBgTkUNFA0ysWQFaMK3SnYj

# **Unsupervised Learning - K-Means Clustering and Hierarchical Clustering - The Heritage Foundation's Economic Freedom Index Analysis 2019 - By David Salako.**


## **Background and Context**

Created in 1995 by the Heritage Foundation, The Index of Economic Freedom is a ranking created to measure the economic freedom in the countries of the world. 

Now, in its 25th edition, The Economic Freedom Index is poised to help readers track over two decades of the advancement in economic freedom, prosperity, and opportunity and promote these ideas in their homes, schools, and communities. 

The Index covers 12 freedoms, from property rights to financial freedom, in 186 countries.

## **Objective:**

As a data scientist, I have been tasked to (1) analyze the data, (2) use clustering algorithms to identify different groups of countries based on economic freedom, and (3) list the insights from the analysis.

##**Data Dictionary & Description:**

The data comprises factors indicating economic freedom. The list of variables in the data is given below. All these features are self-explanatory and more details can be found in the data source listed below.

    * CountryID
    * Country Name
    * WEBNAME
    * Region
    * World Rank
    * Region Rank
    * 2019 Score
    * Property Rights
    * Judical Effectiveness
    * Government Integrity
    * Tax Burden
    * Gov't Spending
    * Fiscal Health
    * Business Freedom
    * Labor Freedom
    * Monetary Freedom
    * Trade Freedom
    * Investment Freedom
    * Financial Freedom
    * Tariff Rate (%)
    * Income Tax Rate (%)
    * Corporate Tax Rate (%)
    * Tax Burden % of GDP
    * Gov't Expenditure % of GDP
    * Country
    * Population (Millions)
    * GDP (Billions, PPP)
    * GDP Growth Rate (%)
    * 5 Year GDP Growth Rate (%)
    * GDP per Capita (PPP)
    * Unemployment (%)
    * Inflation (%)
    * FDI Inflow (Millions)
    * Public Debt (% of GDP)

##**Data Source**

This dataset belongs to The Heritage Foundation and is freely available to download on their website (https://www.heritage.org/index/ranking).

The Index of Economic Freedom considers every component equally important in achieving the positive benefits of economic freedom. 

Each freedom is weighted equally in determining country scores. 

Countries considering economic reforms may find significant opportunities for improving economic performance in those factors in which they score the lowest. 

These factors may indicate significant binding constraints on economic growth and prosperity.

## Importing the necessary libraries.
"""

!pip install yellowbrick

# Commented out IPython magic to ensure Python compatibility.
# this will help in making the Python code more structured automatically (good coding practice)
# %load_ext nb_black

# Libraries to help with reading and manipulating data
import numpy as np
import pandas as pd

# Libraries to help with data visualization
import matplotlib.pyplot as plt
plt.rcParams.update({'figure.max_open_warning': 0})

# %matplotlib inline

import seaborn as sns

# Removes the limit for the number of displayed columns
pd.set_option("display.max_columns", None)
# Sets the limit for the number of displayed rows
pd.set_option("display.max_rows", 200)

# to scale the data using z-score
from sklearn.preprocessing import StandardScaler
from scipy.stats import zscore

# to compute distances
from scipy.spatial.distance import cdist, pdist

# to perform k-means clustering and compute silhouette scores
from sklearn.model_selection  import train_test_split
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

# to perform hierarchical clustering, compute cophenetic correlation, and create dendrograms
from sklearn.cluster import AgglomerativeClustering
from scipy.cluster.hierarchy import dendrogram, linkage, cophenet
from scipy.spatial.distance import pdist

# to visualize the elbow curve and silhouette scores
from yellowbrick.cluster import KElbowVisualizer, SilhouetteVisualizer

# to perform PCA
from sklearn.decomposition import PCA

import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)

# loading the dataset
# EFIndexData_Orig is a dataframe created from csv file
# index_col is setting the dataframe's index to "Country" Column

EFIndexData_Orig = pd.read_csv('economic_freedom_index_2019_data.csv',index_col = 'Country',encoding='ISO-8859-1')

EFIndexData = EFIndexData_Orig.copy()

EFIndexData.shape

"""The dataset has 33 columns and 186 rows of data representing 186 countries."""

# viewing a random sample of the dataset
EFIndexData.sample(n=50, random_state=1)

"""The EFIndexData_Orig dataframe contains every country's economic freedom index and its ranking in 2019. It also displays the related economic indices like Property Rights, Judicial Effectiveness, GDP, etc.
The column "2019 Score" is the economic freedom index, which measures the degree of economic freedom in the 186 nations.
"""

EFIndexData.info()

# Replace the abbrevated column names containing the word "Gov't" with "Government".

EFIndexData.columns=[c.replace("Gov't", "Government") for c in EFIndexData.columns]

# Replace "(%)" in the column names with the string "Percent".

EFIndexData.columns=[c.replace("(%)", "Percent") for c in EFIndexData.columns]

# Replace "%" in the column names with the string "Percent".

EFIndexData.columns=[c.replace("%", "Percent") for c in EFIndexData.columns]

# Replace "(Millions)" in the column names with the string "in Millions".

EFIndexData.columns=[c.replace("(Millions)", "in Millions") for c in EFIndexData.columns]

# Replace "(Billions, PPP)" in the column names with the string "in Billions by PPP in USA Dollars".

EFIndexData.columns=[c.replace("(Billions, PPP)", "in Billions by PPP in USA Dollars") for c in EFIndexData.columns]

# Replace "(Percent of GDP)" in the column names with the string "by Percent of GDP".

EFIndexData.columns=[c.replace("(Percent of GDP)", "by Percent of GDP") for c in EFIndexData.columns]

# Replace "(PPP)" in the column names with the string "by PPP".

EFIndexData.columns=[c.replace("(PPP)", "by PPP") for c in EFIndexData.columns]

EFIndexData.columns=[c.replace("GDP per Capita by PPP", "GDP per Capita by PPP in USA Dollars") for c in EFIndexData.columns]

# Replace the spaces in the column names with "_".

EFIndexData.columns=[c.replace(" ", "_") for c in EFIndexData.columns]

EFIndexData.info()

# Remove the underscore character "_" at the end of the column names.

# EFIndexData['Investment_Freedom_'] = EFIndexData['Investment_Freedom']
# EFIndexData['Government_Expenditure_Percent_of_GDP_'] = EFIndexData['Government_Expenditure_Percent_of_GDP']

EFIndexData.columns=[c.replace("Investment_Freedom_", "Investment_Freedom") for c in EFIndexData.columns]
EFIndexData.columns=[c.replace("Government_Expenditure_Percent_of_GDP_", "Government_Expenditure_Percent_of_GDP") for c in EFIndexData.columns]

EFIndexData.info()

# EFIndexData = EFIndexData.drop(columns = ['Investment_Freedom_', 'Government_Expenditure_Percent_of_GDP_'])

# we will drop the CountryID column add it adds no value to the analysis

EFIndexData.drop("CountryID", axis=1, inplace=True)

# The Region attribute is a categorical variable data type.

EFIndexData.Region = EFIndexData.Region.astype('category')

EFIndexData.info()

"""All 32 of the column names are now nicely formatted with appropriate data types too.

Checking for missing values in the data set.
"""

# Check missing values
def missing_values(df):
    miss_val = df.isnull().sum()
    miss_val_percent = df.isnull().sum() / len(df) * 100
    cols = EFIndexData.columns.values
    sort_ = np.argsort(cols)
    indices = pd.Series(sort_[np.searchsorted(cols,cols,sorter=sort_)],
                       index=cols)
    miss_val_table = pd.concat([indices, miss_val, miss_val_percent],
                               axis=1)
    miss_val_df = miss_val_table.rename(
    columns = {0: "Column Index", 1: "Missing Values", 2: "% Missing"})
    return miss_val_df

missing_values(EFIndexData)

na_count = EFIndexData.isnull().sum(axis=1)
na_EFIndexData = na_count[na_count > 0]
pd.concat([EFIndexData.loc[na_EFIndexData.index]['Country_Name'],na_EFIndexData], 
          axis=1).rename(columns={0: "NA Count"})

"""The 13 countries with missing data are either small nations with low populations (Liechtenstein, Kiribati et al.), isolated (North Korea),  or those experiencing long term conflict (Yemen, Syria, Somalia et al.); none of these charecteristics contribute substantially to a model being designed around global level economic freedom index analysis. The data collected from the isolated and unstable countries are often estimates that may not be relied upon. They are outliers.
Missing data for these territories are attributes such as "2019 Score", "World Rank", "Region Rank", "FDI_Inflow_in_Millions", and "Unemployment Percent". These are not values that can be credibly imputed.

<br/>

*Population_in_Millions*, *GDP_in_Billions_by_PPP_in_USA_Dollars*, *GDP_per_Capita_by_PPP_in_USA_Dollars*, *Unemployment_Percent*, and *FDI_Inflow_in_Millions* are of *object* type in the data but are actually numeric in nature.
"""

# checking for duplicate values
EFIndexData.duplicated().sum()

"""There are no duplicate values in this data set."""

l_df = len(EFIndexData)
# Remove missing data
EFIndexData = EFIndexData.dropna()

# Checking missing values
EFIndexData.isna().sum()

"""No missing values remaining in the data set."""

# Commented out IPython magic to ensure Python compatibility.
print("%s Percent of Original Data Remaining." 
#     %round(len(EFIndexData) / l_df * 100, 2))

# Commented out IPython magic to ensure Python compatibility.
print("%s Countries Remaining in the Data Set." 
#     %len(EFIndexData))

EFIndexData.describe()

# Drop columns by index to be excluded from the model: CountryID and WEBNAME.

# EFIndexData = EFIndexData.drop(EFIndexData.columns[[0,2]], 
#               axis=1)

# Print remaining columns

# EFIndexData.columns

EFIndexData.info()

EFIndexData.head(180)

"""## Data Preprocessing.

### Processing columns.
* Let us process the following columns in order to extract numerical values from them:

  *   Population_in_Millions
  *   GDP_in_Billions_by_PPP_in_USA_Dollars
  *   GDP_per_Capita_by_PPP_in_USA_Dollars
  *   Unemployment_Percent
  *   FDI_Inflow_in_Millions

**1. `Population_in_Millions`**

- Remove the leading and trailing spaces from the column values.
"""

col = "Population_in_Millions"

EFIndexData[col] = EFIndexData[col].str.strip()

"""**2. `GDP_in_Billions_by_PPP_in_USA_Dollars and GDP_per_Capita_by_PPP_in_USA_Dollars`**
- Remove the $ symbol and the commas within the numeric strings.
- Replace them with blank strings.
- Additionally, remove the leading and trailing spaces.



"""

EFIndexData['GDP_in_Billions_by_PPP_in_USA_Dollars'] = EFIndexData['GDP_in_Billions_by_PPP_in_USA_Dollars'].replace({'\$':''}, regex = True)
EFIndexData['GDP_in_Billions_by_PPP_in_USA_Dollars'] = EFIndexData['GDP_in_Billions_by_PPP_in_USA_Dollars'].replace({'\,':''}, regex = True)

EFIndexData['GDP_per_Capita_by_PPP_in_USA_Dollars'] = EFIndexData['GDP_per_Capita_by_PPP_in_USA_Dollars'].replace({'\$':''}, regex = True)
EFIndexData['GDP_per_Capita_by_PPP_in_USA_Dollars'] = EFIndexData['GDP_per_Capita_by_PPP_in_USA_Dollars'].replace({'\,':''}, regex = True)

col1 = "GDP_in_Billions_by_PPP_in_USA_Dollars"
EFIndexData[col1] = EFIndexData[col1].str.strip()

col2 = "GDP_per_Capita_by_PPP_in_USA_Dollars"
EFIndexData[col2] = EFIndexData[col2].str.strip()

EFIndexData.head()

"""**3. `FDI_Inflow_in_Millions`**

- The *FDI_Inflow_in_Millions* column values had commas in between.
- Replace the commas with a blank string.
- We will also remove the leading and trailing spaces.
"""

col4 = "FDI_Inflow_in_Millions"

EFIndexData[col4] = EFIndexData[col4].str.replace(",", "").str.strip()
EFIndexData.head()

# changing FDI_Inflow_in_Millions column datatype from Python object to a numeric float.

EFIndexData[col4] = EFIndexData[col4].astype(float)

EFIndexData.info()

# Changing Population_in_Millions column datatype from Python object to a numeric float.

EFIndexData.Population_in_Millions = EFIndexData.Population_in_Millions.astype(float)

# Changing GDP_per_Capita_by_PPP_in_USA_Dollars column datatype from Python object to a numeric float.

EFIndexData.GDP_per_Capita_by_PPP_in_USA_Dollars = EFIndexData.GDP_per_Capita_by_PPP_in_USA_Dollars.astype(float)

# Changing Unemployment_Percent column datatype from Python object to a numeric float.

EFIndexData.Unemployment_Percent = EFIndexData.Unemployment_Percent.astype(float)

# Changing GDP_in_Billions_by_PPP_in_USA_Dollars column datatype from Python object to a numeric float.

EFIndexData.GDP_in_Billions_by_PPP_in_USA_Dollars = EFIndexData.GDP_in_Billions_by_PPP_in_USA_Dollars.astype(float)

EFIndexData.info()

# viewing a random sample of the dataset

EFIndexData.sample(n=50, random_state=1)

"""For this analysis, I will be keeping the remaining columns and attributes in the data set at this point even though there will most likely be high multi-collinearity due to the nature of how the "2019_Score" Economic Freedom Index is derived. As this is not a regression analysis excercise, the collinearity between some of the independent variables is not a major concern. Additionally, some of the variables are close in nature to one another such as the GDP, Taxation, and Governance but all are individually important nuggets of information that the Heritage Foundation put together.

The zeros that appear in variables such as "Income_Tax_Rate_Percent", "Corporate_Tax_Rate_Percent", "GDP_growth_Rate_Percent", "Fiscal_Health", "Investment_Fredom" etc. will remain as they are valid values for the countries in question.

## Exploratory Data Analysis (EDA).
"""

# A statistical summary of the data.

EFIndexData.describe(include="all").T

"""**Observations**

- The 2019 score varies from 25.9 to 90.2.
- There are 5 regions.
- The income tax rate varies from 0-60%.

### Univariate Analysis.
"""

# function to plot a boxplot and a histogram along the same scale.

def histogram_boxplot(data, feature, figsize=(12, 7), kde=False, bins=None):
    """
    Boxplot and histogram combined

    data: dataframe
    feature: dataframe column
    figsize: size of figure (default (12,7))
    kde: whether to the show density curve (default False)
    bins: number of bins for histogram (default None)
    """
    f2, (ax_box2, ax_hist2) = plt.subplots(
        nrows=2,  # Number of rows of the subplot grid= 2
        sharex=True,  # x-axis will be shared among all subplots
        gridspec_kw={"height_ratios": (0.25, 0.75)},
        figsize=figsize,
    )  # creating the 2 subplots
    sns.boxplot(
        data=data, x=feature, ax=ax_box2, showmeans=True, color="violet"
    )  # boxplot will be created and a star will indicate the mean value of the column
    sns.histplot(
        data=data, x=feature, kde=kde, ax=ax_hist2, bins=bins, palette="winter"
    ) if bins else sns.histplot(
        data=data, x=feature, kde=kde, ax=ax_hist2
    )  # For histogram
    ax_hist2.axvline(
        data[feature].mean(), color="green", linestyle="--"
    )  # Add mean to the histogram
    ax_hist2.axvline(
        data[feature].median(), color="black", linestyle="-"
    )  # Add median to the histogram

# selecting numerical columns

num_col = EFIndexData.select_dtypes(include=np.number).columns.tolist()

for item in num_col:
    histogram_boxplot(EFIndexData, item)

"""**Observations**


* 2019_Score: normal distribution with a few outliers with low scores such as Venezuela and very high scores such as Singapore and Hong Kong. Mean and median scores are close to 60.

* Property_Rights: normally distributed.

* Judicial_Effectiveness: normally distribute with one high outlier being Singapore.

* Government_Integrity: right skewed with low outlier Venuezela.

* Tax_Burden: left skewed data with high taxation countries such as Denmark, France, Belgium, and Sweden as outliers. A high number means low tax burden and a low number indicates a high tax burden.

* Government_Spending: left skewed data set with outliers Timor-Leste, France, and Finland.

* Fiscal_Health: left skewed attribute.

* Business_Freedom: normally distributed with outlier Eritrea.

* Labor_Freedom: normally distributed with outliers such as Turkmenistan.

* Monetary_Freedom: left skewed variable with low outliers such as Venuezela and the Democratic republic of the Congo.

* Trade_Freedom: slight left skew to this attribute.

* Financial_Freedom: normal distribution.

* Tarrif_Rate_Percent: right skewed column.

* GDP_Growth_Rate_Percent: normal distribution with a slight left skew; negative outliers sich as Venezuela and the Democratic Republic of the Congo and high positive oulier Ethiopia.

* 5_Year_GDP_Growth_Rate_Percent: normal distribution with a slight left skew and outlier Venezuela.

* Inflation_Percent: most hover below zero, zero, and above zero with high outliers nations such as Venezuela, Angloa, the Democratic Republic of the Congo and Sudan.

* Public_Dept_by_Percent_of_GDP: near normal distribution with slight right skew and high outliers such as Greece, Japan, and Lebanon.

* Investment_Freedom: normally distributed with a slight left skew.

* Income_Tax_Rate_Percent: the rate varies between 0% to 60%, with a median of 30%.

* Population is heavily right-skewed.

The rest of the fields are either normal distributions or categorical non-numeric variables.
"""

cols_list = EFIndexData.select_dtypes(include=np.number).columns.to_list()
cols_list.remove("World_Rank")
cols_list.remove("Region_Rank")


fig, axes = plt.subplots(9, 3, figsize=(25, 25))
fig.suptitle("CDF plot of numerical variables", fontsize=20)
counter = 0
for ii in range(9):
     sns.ecdfplot(ax=axes[ii][0], x=EFIndexData[cols_list[counter]])
     counter = counter + 1

     sns.ecdfplot(ax=axes[ii][1], x=EFIndexData[cols_list[counter]])
     counter = counter + 1

     sns.ecdfplot(ax=axes[ii][2], x=EFIndexData[cols_list[counter]])
     counter = counter + 1

fig.tight_layout(pad=2.0)

"""**Observations**

The curves illustrate similar information to the earlier boxplots and histograms above.

- 50% of countries have a 2019 score of less than 60.
- 80% of countries have properties right score less than 70.
- 80% of countries have a Judicial Effectiveness score of less than 60. 
- 80% of countries have Govt integrity less than 50. 
- 20% of countries have a tax burden of less than 70.
- 40% of countries have govt spending less than 63.
- 40% of countries have fiscal health less than 70.
- 40% of countries have Business freedom less than 60.
- 60% of countries have labor freedom less than 63.
- 20% of countries have monetary freedom less than 70 with 80% having above 70.
- 60% of countries have trade freedom less than 80.
- 80% of countries have a Tariff Rate of less than 10%.
- 80% of countries have an income tax rate of less than 40%.
- 80% of countries have a corporate tax rate of less than 30%.
- 80% of countries have a Tax burden of less than 33% of their GDP.
- GDP_Growth_Rate_Percent, just under 10% of countries have a zero or negative growth rate.


"""

# function to create labeled barplots


def labeled_barplot(data, feature, perc=False, n=None):
    """
    Barplot with percentage at the top

    data: dataframe
    feature: dataframe column
    perc: whether to display percentages instead of count (default is False)
    n: displays the top n category levels (default is None, i.e., display all levels)
    """

    total = len(data[feature])  # length of the column
    count = data[feature].nunique()
    if n is None:
        plt.figure(figsize=(count + 1, 5))
    else:
        plt.figure(figsize=(n + 1, 5))

    plt.xticks(rotation=90, fontsize=15)
    ax = sns.countplot(
        data=data,
        x=feature,
        palette="Paired",
        order=data[feature].value_counts().index[:n].sort_values(),
    )

    for p in ax.patches:
        if perc:
            label = "{:.1f}%".format(
                100 * p.get_height() / total
            )  # percentage of each class of the category
        else:
            label = p.get_height()  # count of each level of the category

        x = p.get_x() + p.get_width() / 2  # width of the plot
        y = p.get_height()  # height of the plot

        ax.annotate(
            label,
            (x, y),
            ha="center",
            va="center",
            size=12,
            xytext=(0, 5),
            textcoords="offset points",
        )  # annotate the percentage

    plt.show()  # show the plot

# Let's explore Region further
labeled_barplot(EFIndexData, "Region", perc=True)

"""**Observations**

* The Sub-Saharan Africa region has the largest number of countries at 46 (26.6%) in this data set which is in line with the African continent being the second largest in terms of size and having the highest number of nations at 54/55.

* Europe and Asia-Pacific have the next two largest groups of nations.

* The Americas and Middle East and North Africa have the least amount of countries in terms of count.
"""

EFIndexData.groupby('Region').size()

"""**Observations**

According to Times World Atlas,there are:
* 35 countries in the Americas,
* 48 countries in Asia-Pacific, 
* 44 countries in Europe,
* 17 countries in Middle East and North Africa, and 
* 48 countries in Sub-Saharan Africa. 

Apart from Asia-Pacific, all the other regions include more than 90% of their countries.

### Bivariate Analysis

**Checking for correlations.**
"""

plt.figure(figsize=(25, 15))
sns.heatmap(EFIndexData[num_col].corr(), annot=True, vmin=-1, vmax=1, fmt=".1f", cmap="Spectral")
plt.show()

"""**Observations**

As alluded to earlier in this analysis there are several correlated variables in this data set which is by design and most are obvious too. Some examples of highly correlated columns are:

* Tax_Burden and Income_Tax_Rate (-0.90)
* Property_Rights and Business_Freedom (0.80)
* Property_Rights and Investment_Freedom (0.66)
* Property_Rights and Financial_Freedom (0.73)
* Property_Rights and Government_Integrity (0.87)
* Property_Rights and Judicial_Effectiveness (0.83)
* Judicial_Effectiveness and Business_Freedom (0.70)
* Judicial_Effectiveness and Government_Integrity (0.89)
* Government_Integrity and Business_Freedom (0.74)
* Government_Integrity and Property_Rights (0.87)
* Government_Spending and Tax_Burden_Percent_of_GDP (-0.71)
* Monetary_Freedom and Inflation_Percent (-0.65)
* Trade_Freedom and Tarrif_Rate_Percent (-0.95)
* Population_in_Millions and GDP_in_Billions_By_PPP_in_USA_Dollars (0.8)
* Monetary_Freedom and Inflation_Percent (-0.7)
* FDI-Inflow_in_Millions and GDP_in_Billions_by_PPP_in_USA_Dollars (0.8)



"""

sns.pairplot(data=EFIndexData[cols_list], diag_kind="kde")
plt.show()

EFIndexData.groupby('Region')['2019_Score'].mean().sort_values().plot.barh()

"""**Observations**

* From the horizontal bar plot above, according to the dataset, in 2019, Europe enjoys the highest economic freedom level on average.

"""

EFIndexData.groupby('Region')['2019_Score'].std()

"""**Observations**

Which region has the largest standard deviation in the 2019 Economic Freedom Index?:

* The Asia-Pacific region has the largest standard deviation followed by the 
* Americas and then  
* Middle East and North Africa subsequented by
* Sub-Saharan Africa  and finally the region with the least is
* Europe.

"""

sns.pairplot(data=EFIndexData[num_col], diag_kind="kde")
plt.show()

"""**Observations**

- The pairplot chart further illustrates the observations mentioned in the earlier analyses.
- *Tariff_Rate-Percent* and *Trade_Freedom* are perfectly negatively correlated.
- *2019 Score* is highly positively correlated with many variables.

We will drop the *Tariff_Rate_Percent* column from the data.
"""

EFIndexData.drop("Tariff_Rate_Percent", axis=1, inplace=True)

"""### Data Preprocessing

#### Scaling
"""

scaler = StandardScaler()
to_exclude = [
    "CountryID",
    "Country_Name",
    "WEBNAME",
    "Region",
    "World_Rank",
    "Region_Rank",
    "Country",
]

# columns to be used for clustering are
col_for_clustering = [c for c in EFIndexData.columns if c not in to_exclude]
print(col_for_clustering)

EFIndexData_scaled = EFIndexData[col_for_clustering].copy()
EFIndexData_scaled.iloc[:, :] = scaler.fit_transform(EFIndexData_scaled.iloc[:, :])
EFIndexData_scaled.head()

# creating dataframe copies for k-means and hierarchical clustering
km_EFIndexData = EFIndexData.copy()
hc_EFIndexData = EFIndexData.copy()

"""### Clustering

#### K-means Clustering
"""

clusters = range(2, 11)
meanDistortions = []

for k in clusters:
    model = KMeans(n_clusters=k)
    model.fit(EFIndexData_scaled)
    prediction = model.predict(EFIndexData_scaled)
    distortion = (
        sum(
            np.min(cdist(EFIndexData_scaled, model.cluster_centers_, "euclidean"), axis=1)
        )
        / EFIndexData_scaled.shape[0]
    )

    meanDistortions.append(distortion)

    print("Number of Clusters:", k, "\tAverage Distortion:", distortion)

plt.plot(clusters, meanDistortions, "bx-")
plt.xlabel("k")
plt.ylabel("Average distortion")
plt.title("Selecting k with the Elbow Method")
plt.show()

"""**Observations**

The appropriate value of k from the Elbow curve seems to be 3, 5, 6, or 7.
"""

model = KMeans(random_state=1)
visualizer = KElbowVisualizer(model, k=(2, 11), timings=True)
visualizer.fit(EFIndexData_scaled)  # fit the data to the visualizer
visualizer.show()  # finalize and render figure

"""**Check the silhouette scores.**"""

sil_score = []
cluster_list = list(range(2, 11))
for n_clusters in cluster_list:
    clusterer = KMeans(n_clusters=n_clusters)
    preds = clusterer.fit_predict((EFIndexData_scaled))
    # centers = clusterer.cluster_centers_
    score = silhouette_score(EFIndexData_scaled, preds)
    sil_score.append(score)
    print("For n_clusters = {}, the silhouette score is {})".format(n_clusters, score))

plt.plot(cluster_list, sil_score)
plt.show()

model = KMeans(random_state=1)
visualizer = KElbowVisualizer(model, k=(2, 11), metric="silhouette", timings=True)
visualizer.fit(EFIndexData_scaled)  # fit the data to the visualizer
visualizer.show()  # finalize and render figure

"""**Observations**

From the silouette scores, it seems that 4 is a reasonable value for k.

**Silhouette Plot**
"""

# Finding optimal no. of clusters with silhouette coefficients
visualizer = SilhouetteVisualizer(KMeans(2, random_state=1))
visualizer.fit(EFIndexData_scaled)
visualizer.show()

# Finding optimal no. of clusters with silhouette coefficients

visualizer = SilhouetteVisualizer(KMeans(3, random_state=1))
visualizer.fit(EFIndexData_scaled)
visualizer.show()

# Finding optimal no. of clusters with silhouette coefficients
visualizer = SilhouetteVisualizer(KMeans(4, random_state=1))
visualizer.fit(EFIndexData_scaled)
visualizer.show()

# Finding optimal no. of clusters with silhouette coefficients
visualizer = SilhouetteVisualizer(KMeans(5, random_state=1))
visualizer.fit(EFIndexData_scaled)
visualizer.show()

# Finding optimal no. of clusters with silhouette coefficients
visualizer = SilhouetteVisualizer(KMeans(6, random_state=1))
visualizer.fit(EFIndexData_scaled)
visualizer.show()

"""**We will proceed with k=4.**

**Check additional internal performance evaluation scores as well as external performance evaluation scores too.**
"""

# Make a copy of the data set for the evaluation scores

EFIndexData_scaled_Scores = EFIndexData_scaled.copy()

# split dataset in two parts: features and target 

features = EFIndexData_scaled_Scores.drop(['2019_Score'], axis=1)

target = EFIndexData_scaled_Scores['2019_Score']
 
# partition data into training and testing set 

from sklearn.model_selection import train_test_split
feature_train, feature_test, target_train, target_test = train_test_split(features, target, test_size=0.3, random_state=1)

# Import metrics module for performance evaluation

from sklearn.metrics import davies_bouldin_score
from sklearn.metrics import adjusted_rand_score
from sklearn.metrics import fowlkes_mallows_score
 
# Specify the number of clusters
num_clusters = 4
 
# Create and fit the KMeans model
clusterer = KMeans(n_clusters=num_clusters)
clusterer.fit(feature_train)
 
# Predict the target variable
predictions=clusterer.predict(feature_test)
 
# Calculate internal performance evaluation measures
print('Internal performance evaluation measures:')
print('                                        ')
print("Davies-Bouldin Index:", davies_bouldin_score(feature_test, predictions))
print("Silhouette Coefficient:", silhouette_score(feature_test, predictions))
print('                                        ')
# Calculate External performance evaluation measures
print('External performance evaluation measures:')
print('                                        ')
print("Adjusted Rand Score:", adjusted_rand_score(target_test, predictions))
print("Fowlkes Mallows Score:", fowlkes_mallows_score(target_test, predictions))
print('                                        ')

"""**Observations**

Using 3 clusters the evaluation measures give us the above detailed scores. 

* A Davies-Bouldin index score of approximately 1.2 is okay as the closer the score is to 1 the better the quality of the clusters. 

* The Silhouette coefficient is 0.22 is a decent one for the number of clusters.

* An Adjusted Rand Score close to zero is not that great an indicator that the clusters are not similar. Perfect labeling would be scored 1 and bad labelling or independent labelling is scored 0 or negative.

* The minimum possible value of the Fowlkes–Mallows index is 0, which corresponds to the worst binary classification possible, where all the elements have been misclassified. And the maximum possible value of the Fowlkes–Mallows index is 1, which corresponds to the best binary classification possible, where all the elements have been perfectly classified.  Our Fowlkes Mallows score of 0.06 is not that great.


"""

# let's take 4 as number of clusters
kmeans = KMeans(n_clusters=4, random_state=0)
kmeans.fit(EFIndexData_scaled)

# adding kmeans cluster labels to the original and scaled dataframes

km_EFIndexData["K_means_segments"] = kmeans.labels_
EFIndexData_scaled["K_means_segments"] = kmeans.labels_

"""#### Hierarchical Clustering"""

# list of distance metrics
distance_metrics = ["euclidean", "chebyshev", "mahalanobis", "cityblock"]

# list of linkage methods
linkage_methods = ["single", "complete", "average", "weighted"]

high_cophenet_corr = 0
high_dm_lm = [0, 0]

for dm in distance_metrics:
    for lm in linkage_methods:
        Z = linkage(EFIndexData_scaled, metric=dm, method=lm)
        c, coph_dists = cophenet(Z, pdist(EFIndexData_scaled))
        print(
            "Cophenetic correlation for {} distance and {} linkage is {}.".format(
                dm.capitalize(), lm, c
            )
        )
        if high_cophenet_corr < c:
            high_cophenet_corr = c
            high_dm_lm[0] = dm
            high_dm_lm[1] = lm

# printing the combination of distance metric and linkage method with the highest cophenetic correlation

print(
    "Highest cophenetic correlation is {}, which is obtained with {} distance and {} linkage.".format(
        high_cophenet_corr, high_dm_lm[0].capitalize(), high_dm_lm[1]
    )
)

# list of linkage methods
linkage_methods = ["single", "complete", "average", "centroid", "ward", "weighted"]

# lists to save results of cophenetic correlation calculation
compare_cols = ["Linkage", "Cophenetic Coefficient"]
compare = []

# to create a subplot image
fig, axs = plt.subplots(len(linkage_methods), 1, figsize=(15, 30))

# We will enumerate through the list of linkage methods above
# For each linkage method, we will plot the dendrogram and calculate the cophenetic correlation
for i, method in enumerate(linkage_methods):
    Z = linkage(EFIndexData_scaled, metric="euclidean", method=method)

    dendrogram(Z, ax=axs[i])
    axs[i].set_title(f"Dendrogram ({method.capitalize()} Linkage)")

    coph_corr, coph_dist = cophenet(Z, pdist(EFIndexData_scaled))
    axs[i].annotate(
        f"Cophenetic\nCorrelation\n{coph_corr:0.2f}",
        (0.80, 0.80),
        xycoords="axes fraction",
    )

    compare.append([method, coph_corr])

"""**Observations**

- Looking the the above dendrograms, the Ward linkage seems to result in the best separation between clusters, even though its cophenetic correlation is lower than the other linkages.
- 4 looks to be a good choice for k.
"""

hc = AgglomerativeClustering(n_clusters=4, affinity="euclidean", linkage="ward")
hc_labels = hc.fit_predict(EFIndexData_scaled)

hc_EFIndexData["HC_segments"] = hc_labels

"""## Clustering Profiling and Comparison

### K-means Clustering
"""

pd.crosstab(km_EFIndexData.K_means_segments, km_EFIndexData.Region)

"""**Observations**

- Majority of the European countries are in Cluster 0 and Cluster 1.
- Majority of Asia-Pacific, American, MIddle East, and North Africa countries are in Cluster 0 and Cluster 2.
- Almost all Sub-Saharan African countries are in Cluster 2.
- There are an additional 9 countries asides from European nations in cluster 1.
- Cluster 3 has only 3 cointries in it (2 from the Asia-Pacific Region and 1 from the Americas).
"""

clusters = km_EFIndexData.K_means_segments.unique().tolist()
for cl in clusters:
    print(
        "The",
        km_EFIndexData[km_EFIndexData["K_means_segments"] == cl]["Country_Name"].nunique(),
        "countries in cluster",
        cl,
        "are:",
    )
    print(km_EFIndexData[km_EFIndexData["K_means_segments"] == cl]["Country_Name"].unique())
    print("-" * 100, "\n")

km_EFIndexData_profiling = km_EFIndexData.groupby("K_means_segments")[col_for_clustering].mean()
km_EFIndexData_profiling["count_in_each_segment"] = (
    km_EFIndexData.groupby("K_means_segments")["2019_Score"].count().values
)

# displaying the group-wise means of variables
km_EFIndexData_profiling.style.highlight_max(color="green", axis=0)

# let's plot the attributes of only the big clusters
c1 = [0, 1, 2]
km_EFIndexData2 = km_EFIndexData[km_EFIndexData.K_means_segments.isin(c1)]

fig, axes = plt.subplots(7, 4, figsize=(25, 35))
counter = 0

for ii in range(7):
    for jj in range(4):
        if counter < 26:
            sns.boxplot(
                ax=axes[ii][jj],
                y=km_EFIndexData2[col_for_clustering[counter]],
                x=km_EFIndexData2["K_means_segments"],
            )
            counter = counter + 1

fig.tight_layout(pad=3.0)

"""### Insights

- **Cluster 0**:
  - There are 68 countries in this cluster.
  - Countries in this cluster have a moderate 2019 score with a mean value of ~66.
  - Countries in this cluster have moderate business and trade freedom scores.
  - The mean population across countries in this cluster is low.
  - Countries in this cluster have a mean low GDP (with a large spread) and a moderate GDP growth rate.
  - The unemployment rate of the countries in this cluster has a high variance with a comparatively high mean and very high outliers.
  - Comparatively moderate amounts of foreign domestic investment (FDI) on average in these countries with very moderate variance and several outliers.
  - Comparatively slightly lower public debt with large variance.


- **Cluster 1**:
  - There are 29 countries in this cluster.
  - Countries in this cluster have a high 2019 score with a mean value of ~76.
  - Countries in this cluster have high business and trade freedom scores.
  - The mean population across countries in this cluster is moderate with a large spread.
  - Countries in this cluster have a high GDP and low GDP growth rates.
  - The unemployment rate of the countries in this cluster has a low variance with a comparatively moderate mean and some outliers.
  - Large amounts of foreign domestic investment (FDI) on average in these countries with high variance.
  - Large public debt with large variance and highest outlier comparatively with these 3 clusters.


- **Cluster 2**:
  - There are 73 countries in this cluster.
  - Countries in this cluster have a low 2019 score with a mean value of ~55.
  - Countries in this cluster have low business and trade freedom scores.
  - The mean population across countries in this cluster is high with a narrower spread and many outliers.
  - Countries in this cluster have a low GDP and high GDP growth rates.
  - The unemployment rate of the countries in this cluster has a large variance with a comparatively lower mean and outliers.
  - Comparatively smaller amounts of foreign domestic investment (FDI) on average in these countries with very low variance.
  - Similar public debt distribution to cluster 0 with several outliers though highets outlier is not as high as cluster 0 and cluster 1.

### Hierarchical Clustering
"""

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData.Region)

"""**Observations**

- Majority of the European countries are in Cluster 1 and Cluster 2.
- Majority of Asia-Pacific, American, Middle East, and North Africa countries are in Cluster 0 and Cluster 2.
- Almost all Sub-Saharan African countries are in Cluster 0.
- There are only 3 countries in Cluster 3.
"""

clusters = hc_EFIndexData.HC_segments.unique().tolist()
for cl in clusters:
    print(
        "The",
        hc_EFIndexData[hc_EFIndexData["HC_segments"] == cl]["Country_Name"].nunique(),
        "countries in cluster",
        cl,
        "are:",
    )
    print(hc_EFIndexData[hc_EFIndexData["HC_segments"] == cl]["Country_Name"].unique())
    print("-" * 100, "\n")

hc_EFIndexData_profiling = hc_EFIndexData.groupby("HC_segments")[col_for_clustering].mean()
hc_EFIndexData_profiling["count_in_each_segment"] = (
    hc_EFIndexData.groupby("HC_segments")["2019_Score"].count().values
)

# displaying the group-wise means of variables
hc_EFIndexData_profiling.style.highlight_max(color="blue", axis=0)

# Let's plot the attributes of only the big clusters
c1 = [0, 1, 2]
hc_EFIndexData2 = hc_EFIndexData[hc_EFIndexData.HC_segments.isin(c1)]

fig, axes = plt.subplots(7, 4, figsize=(25, 35))
counter = 0

for ii in range(7):
    for jj in range(4):
        if counter < 26:
            sns.boxplot(
                ax=axes[ii][jj],
                y=hc_EFIndexData2[col_for_clustering[counter]],
                x=hc_EFIndexData2["HC_segments"],
            )
            counter = counter + 1

fig.tight_layout(pad=2.0)

"""### Insights

- **Cluster 0**:
  - There are 76 countries in this cluster.
  - Countries in this cluster have a low 2019 score with a mean value of ~54.
  - Countries in this cluster have low business and trade freedom scores.
  - The mean population across countries in this cluster is high with wide variance.
  - Countries in this cluster have a low GDP and comparatively high GDP growth rate with wide variance from -15% to 11%.
  - The unemployment rate of the countries in this cluster has moderate variance with a comparatively low mean.
  - Comparatively low amounts of foreign domestic investment (FDI) on average in these countries with very moderate variance and several outliers.
  - Comparatively moderate public debt with large variance.



- **Cluster 1**:
  - There are 62 countries in this cluster.
  - Countries in this cluster have a high 2019 score with a mean value of ~76.
  - Countries in this cluster have high business and trade freedom scores.
  - The mean population across countries in this cluster is comparativfely moderate with high variance and the highest positive number outlier in all 3 cluisters.
  - Countries in this cluster have a high GDP and comparatively low GDP growth rate.
  - The unemployment rate of the countries in this cluster has a moderate variance with a comparatively moderate mean.
  - Comparatively high amounts of foreign domestic investment (FDI) on average in these countries with very high variance and a few outliers.
  - Comparatively high public debt with large variance.


- **Cluster 2**:
  - There are 32 countries in this cluster.
  - Countries in this cluster have a moderate 2019 score with a mean value of ~66.
  - Countries in this cluster have moderate business and trade freedom scores.
  - The mean population across countries in this cluster is low.
  - Countries in this cluster have a moderate GDP and comparatively moderate GDP growth rate.
  - The unemployment rate of the countries in this cluster has wide variance with a comparatively high mean.
  - Comparatively low amounts of foreign domestic investment (FDI) on average in these countries with low variance and several outliers.
  - Comparatively moderate public debt with large variance.

### K-Means Clustering vs Hierarchical Clustering Comparison
"""

km_EFIndexData_profiling.style.highlight_max(color="green", axis=0)

clusters = km_EFIndexData.K_means_segments.unique().tolist()
for cl in clusters:
    print(
        "The",
        km_EFIndexData[km_EFIndexData["K_means_segments"] == cl]["Country_Name"].nunique(),
        "countries in cluster",
        cl,
        "are:",
    )
    print(km_EFIndexData[km_EFIndexData["K_means_segments"] == cl]["Country_Name"].unique())
    print("-" * 100, "\n")

hc_EFIndexData_profiling.style.highlight_max(color="blue", axis=0)

clusters = hc_EFIndexData.HC_segments.unique().tolist()
for cl in clusters:
    print(
        "The",
        hc_EFIndexData[hc_EFIndexData["HC_segments"] == cl]["Country_Name"].nunique(),
        "countries in cluster",
        cl,
        "are:",
    )
    print(hc_EFIndexData[hc_EFIndexData["HC_segments"] == cl]["Country_Name"].unique())
    print("-" * 100, "\n")

"""**Observations**

- Looks like the K-Means and Hierarchical clusters are similar, except that the labels are swapped between clusters 0 and 2 and some of the countries have changed clusters.
- Let us swap the labels for K-Means for better analysis and comparison.
"""

km_EFIndexData["K_means_segments"] = km_EFIndexData["K_means_segments"].replace({0: 2, 2: 0})

km_EFIndexData_profiling = km_EFIndexData.groupby("K_means_segments")[col_for_clustering].mean()
km_EFIndexData_profiling["count_in_each_segment"] = (
    km_EFIndexData.groupby("K_means_segments")["2019_Score"].count().values
)

km_EFIndexData_profiling.style.highlight_max(color="green", axis=0)

clusters = km_EFIndexData.K_means_segments.unique().tolist()
for cl in clusters:
    print(
        "The",
        km_EFIndexData[km_EFIndexData["K_means_segments"] == cl]["Country_Name"].nunique(),
        "countries in cluster",
        cl,
        "are:",
    )
    print(km_EFIndexData[km_EFIndexData["K_means_segments"] == cl]["Country_Name"].unique())
    print("-" * 100, "\n")

"""**Observations**

- The country segments based on economic freedom matches to a large extent for both K-means and Hierarchical Clustering techniques.
- Cluster 3 is identical in both techniques with only 3 nations China, India, and the United States of America. These are 3 countries with very large populations.
- A few other countries have swapped clusters between K-means and Hierarchical clustering.

**Compare Hierarchical Clusters vs Various Attributes in the Data Set.**
"""

pd.crosstab(hc_EFIndexData.HC_segments, EFIndexData.Region).style.highlight_max(
    color="blue", axis=0
)

"""**Observations**

* Cluster 1 are the "developed countries" of which the majority are European nations, Cyprus, Australia, New Zealand, Canada, Japan, Taiwan, Hong Kong, Singapore, South Korea, and Israel.

* Cluster 2 are the "upper tier developing nations" with nations like Brazil, South Africa, Mexico, Botswana etc. to name a few. There might be some nations that should not be in this particular cluster such as eSwatini and Lesotho but there proximity and reliance on South African infrastructure skews their statistics; this is based on my domain knowledge of the economies of these 2 countries.

* Cluster 0 are the "lower tier developing nations" or "emerging nations" most of which are in Sub-Saharan Africa, South America and scattered territories in the the rest of the world.

* Cluster 3 are the countries with the largest populations in the world - China, India, and the United States of America. They also have the first (U.S.A), second (China), and fifth (India) largest economies in the world respectively. They are a unique trio of nations.
"""

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Government_Integrity']).style.highlight_max(
    color="green", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Property_Rights']).style.highlight_max(
    color="yellow", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Judical_Effectiveness']).style.highlight_max(
    color="grey", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Tax_Burden']).style.highlight_max(
    color="orange", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Fiscal_Health']).style.highlight_max(
    color="cyan", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Labor_Freedom']).style.highlight_max(
    color="pink", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Monetary_Freedom']).style.highlight_max(
    color="yellow", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Trade_Freedom']).style.highlight_max(
    color="purple", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Investment_Freedom']).style.highlight_max(
    color="red", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Financial_Freedom']).style.highlight_max(
    color="blue", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Income_Tax_Rate_Percent']).style.highlight_max(
    color="brown", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Corporate_Tax_Rate_Percent']).style.highlight_max(
    color="orange", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Tax_Burden_Percent_of_GDP']).style.highlight_max(
    color="red", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Government_Expenditure_Percent_of_GDP']).style.highlight_max(
    color="pink", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Population_in_Millions']).style.highlight_max(
    color="lightblue", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['GDP_in_Billions_by_PPP_in_USA_Dollars']).style.highlight_max(
    color="green", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Unemployment_Percent']).style.highlight_max(
    color="red", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Inflation_Percent']).style.highlight_max(
    color="teal", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['FDI_Inflow_in_Millions']).style.highlight_max(
    color="yellow", axis=0
)

pd.crosstab(hc_EFIndexData.HC_segments, hc_EFIndexData['Public_Debt_by_Percent_of_GDP']).style.highlight_max(
    color="green", axis=0
)

"""**Observations**

The tables above break down the distributions of the countries and where they fall within their cluster along the scale of the variable in question. For example "Government_Integrity" has Cluster 1 having the highest scores, Cluster 0 with the lowest, and Cluster 2 in the middle. The unique trio in cluster 3 report "Government_Integrity" scores of 47.8 (China), 49.1 (India), amd 77.4 (U.S.A.) respectively. Similar distributions for "Property_Rights", "Judicial_Effectiveness", "Fiscal_Health", and the five "Freedom" variables.

These illustrations further highlight and add to the analyses done earlier.

"""

hc_EFIndexData.groupby(hc_EFIndexData.HC_segments)[['2019_Score','GDP_Growth_Rate_Percent','Inflation_Percent', 'Property_Rights', 'Trade_Freedom','Fiscal_Health','Judical_Effectiveness']].mean()

"""**Observations**

* Cluster 1 the "developed countries": Highest average "2019_Score", "Property_Rights", "Trade_Freeom", "Fiscal_Health", and "Judicial_Effectiveness". Lowest mean "Inflation_Percent".

* Cluster 2 the "upper tier developing nations": consistently middle in between the other two clusters for all seven variables.

* Cluster 0 the "lower tier developing nations" or "emerging nations": highest mean "Inflation_Percent" and "GDP_Growth_Rate_Percent". Consistently lowest means in the remaining 5 attributes.

* Cluster 3 are the special group of the U.S.A., China, and India.
"""

hc_EFIndexData.groupby(hc_EFIndexData.HC_segments)[['2019_Score','Business_Freedom','Investment_Freedom','Labor_Freedom','Government_Integrity','Financial_Freedom','Income_Tax_Rate_Percent']].mean()

"""**Which countries have the highest "2019_Score" within each Hierarchical cluster?**"""

data_subset=hc_EFIndexData[['HC_segments','Country_Name','2019_Score']]
sort=data_subset.groupby(['HC_segments'])['2019_Score'].transform(max) == data_subset['2019_Score']
data_subset[sort]

"""**Which countries have the lowest "2019_Score" within each Hierarchical cluster?**"""

data_subset=hc_EFIndexData[['HC_segments','Country_Name','2019_Score']]
sort=data_subset.groupby(['HC_segments'])['2019_Score'].transform(min) == data_subset['2019_Score']
data_subset[sort]

# Let us see the names of the countries in each cluster
for cl in hc_EFIndexData["HC_segments"].unique():
    print("In cluster {}, the following countries are present:".format(cl))
    print(hc_EFIndexData[hc_EFIndexData["HC_segments"] == cl]["Country_Name"].unique())
    print()

"""**Observations**

* Cluster 1 are the "developed countries" of which the majority are European nations, Cyprus, Australia, New Zealand, Canada, Japan, Taiwan, Hong Kong, Singapore, South Korea, and Israel.

* Cluster 2 are the "upper tier developing nations" with nations like Brazil, South Africa, Mexico, Botswana etc. to name a few. There might be some nations that should not be in this particular cluster such as eSwatini and Lesotho; their circumscription by South Africa most likely skews their statistics towards this cluster; this is based on my domain knowledge of the economies of these 2 countries.


* Cluster 0 are the "lower tier developing nations" or "emerging nations" most of which are in Sub-Saharan Africa, South America and scattered territories in the the rest of the world.

* Cluster 3 is the unique trio of the U.S.A., China, and India; countries with large populations and large economies.

### Insights

I have lived and worked on three continents thus far in my life and have traveled to five continents. There is wide variety in economic conditions and standards of living across the world and I have often wondered why this is the case? A country having strong institutions and robust policies are frequently mentioned as key to enabling sustained economic growth as well as rapid development. 
<br>
<br>

Some countries are very organized and have well thought out laws that are enforceable by capable and independent legislative and judicial systems. Other nations are endemic with corruption which can discourage investors both from within and from without. Additionally, some governmental and political environments make it very challenging for private enterprise to succeed and thrive. 
<br>
<br>

Several organizations compile economic data to try to quantitatively measure or score the quality of governance and economic climate among the many nations and territories of our world. The Heritage Foundation is a Washington D.C. based think tank publishes the Economic Freedom Index covers 12 freedoms – from property rights to financial freedom – in 184 countries. For twenty-seven years the Index has delivered thoughtful analysis in a clear, friendly, and straight-forward format. The Index of Economic Freedom is poised to help readers track over two decades of the advancement in economic freedom, prosperity, and opportunity and promote these ideas in their homes, schools, and communities. 
<br>
<br>

Research and studies have demonstrated that this Index does in many ways correspond strongly to economic growth. Economic theory predicts that increased freedoms will almost certainly lead to improved prosperity.
<br>
<br>

**===============================================================================================================**
<br>
<br>

I have used the 2019 Economic Freedom Index data set to group the reporting nations into high level clusters based on shared characteristics. As expected, there is also diversity within the clusters too. Focusing on the 3 clusters created using Hierarchical Clustering method they are:
<br>
<br>

**Developed Countries (Hierarchical Cluster 1 in alphabetical order)**
<br>
<br>
'Australia', 'Austria', 'Belgium', 'Canada', 'Chile', 'Croatia', 'Cyprus',
 'Denmark', 'Estonia', 'Finland', 'France', 'Germany', 'Greece', 'Hong Kong',
 'Iceland', 'Ireland', 'Israel', 'Italy', 'Japan', 'Korea, South', 'Luxembourg',
 'Netherlands', 'New Zealand', 'Norway', 'Portugal', 'Singapore', 'Slovenia',
 'Spain', 'Sweden', 'Switzerland', 'Taiwan', and 'United Kingdom'.
<br>
<br>
'Hong Kong' has the highest '2019 Score' in this cluster and 'Greece' has the lowest score among the developed countries.
<br>
<br>

Some of the characteristics of the developed countries are high freedom scores (financial, investment, trade, monetary, and labor), fiscal health scores above 51.0, and a tax burden of mostly below 76.8 with outliers Singapore and Hong Kong in the 90s. Furthermore, high judicial effectiveness (above 46.5) and property rights (52.4 and higher) seem  to work in tandem with government integrity score of 50.5 and more with Croatia being the outlier at 38.6.

Income tax rate percentages are high with most of the developed countries above 31.3; corporate tax rate percentages are in the middle tier realm of between 12.5 and 35.0. Inflation rates are low (0.2 to 2.7) with unemployment rates spread out across the spectrum.

<br>
<br>

**Developing Countries - Upper Tier (Hierarchical Cluster 2 in alphabetical order)**

<br>
<br>

'Albania', 'Armenia', 'Azerbaijan', 'Bahamas', 'Bahrain', 'Barbados', 'Belarus',
 'Bhutan', 'Bosnia and Herzegovina', 'Botswana', 'Brunei Darussalam',
 'Bulgaria', 'Cabo Verde', 'Colombia', 'Costa Rica', 'Czech Republic',
 'Eswatini', 'Fiji', 'Georgia', 'Hungary', 'Indonesia', 'Jamaica', 'Jordan',
 'Kazakhstan', 'Kuwait', 'Kyrgyz Republic', 'Latvia', 'Lesotho', 'Lithuania',
 'Macau', 'Macedonia', 'Malaysia', 'Maldives', 'Malta', 'Mauritius', 'Mexico',
 'Mongolia', 'Montenegro', 'Morocco', 'Namibia', 'Oman', 'Panama', 'Peru',
 'Poland', 'Qatar', 'Romania', 'Russia', 'Rwanda', 'Saint Lucia',
 'Saint Vincent and the Grenadines', 'Samoa', 'Saudi Arabia', 'Serbia',
 'Slovakia', 'South Africa', 'Thailand', 'Tonga', 'Trinidad and Tobago',
 'Turkey', 'United Arab Emirates', 'Uruguay', and 'Vanuatu'.
<br>
<br>
'United Arab Emirates' has the highest '2019 Score' in this cluster and 'Lesotho' has the lowest score among the developing countries - upper tier.

<br>
<br>

Some of the characteristics of the developing countries upper tier are middle tier freedom scores (financial, investment, trade, monetary, and labor), fiscal health scores range from 3.7 in Bahrain to 100 in Macau, and a tax burden of range of 62.1 in South Africa to 99.8 in Saudi Arabia. Furthermore, judicial effectiveness goes from 23.8 to 68.2 with Rwanda and the U.A.E. being above 80 and property rights (37.6 to 84.1) seem  to work in tandem with government integrity score spanning 23.4 to 78.8 in the U.A.E.

Income tax rate percentages are at 0.0 in several oil-rich Middle Eastern nations, Bahamas, and Vanuatu and top of at 38.0 in Morocco; corporate tax rate percentages are spread from 0.0 to 33 with ten nations at 25.0. Inflation rates range from -0.9 deflation in Saudi Arabia to 13.0 in Azerbaijan with unemployment rates spread out across the spectrum starting at 0.1 to 9.7 in Bahamas.

<br>
<br>

**Developing Countries - Lower Tier - Emerging Economies (Hierarchical Cluster 0 in alphabetical order)**

<br>
<br>

'Afghanistan', 'Algeria', 'Angola', 'Argentina', 'Bangladesh', 'Belize',
 'Benin', 'Bolivia', 'Brazil', 'Burkina Faso', 'Burma', 'Burundi', 'Cambodia',
 'Cameroon', 'Central African Republic', 'Chad', 'Comoros',
 'Congo, Democratic Republic of the Congo', 'Congo, Republic of',
 "Côte d'Ivoire", 'Djibouti', 'Dominican Republic', 'Ecuador', 'Egypt',
 'El Salvador', 'Equatorial Guinea', 'Eritrea', 'Ethiopia', 'Gabon', 'Gambia',
 'Ghana', 'Guatemala', 'Guinea', 'Guinea-Bissau', 'Guyana', 'Haiti', 'Honduras',
 'Iran', 'Kenya', 'Laos', 'Lebanon', 'Liberia', 'Madagascar', 'Malawi', 'Mali',
 'Mauritania', 'Moldova', 'Mozambique', 'Nepal', 'Nicaragua', 'Niger', 'Nigeria',
 'Pakistan', 'Papua New Guinea', 'Paraguay', 'Philippines',
 'São Tomé and Príncipe', 'Senegal', 'Sierra Leone', 'Solomon Islands',
 'Sri Lanka', 'Sudan', 'Suriname', 'Tajikistan', 'Tanzania', 'Timor-Leste',
 'Togo', 'Tunisia', 'Turkmenistan', 'Uganda', 'Ukraine', 'Uzbekistan',
 'Venezuela', 'Vietnam', 'Zambia', and 'Zimbabwe'.
<br>
The 'Philippines' has the highest '2019 Score' in this cluster and 'Venezuela' has the lowest score among the developing countries - lower tier - emerging economies.
<br>
<br>

Some of the characteristics of the developing countries lower tier emerging economies are low freedom scores (financial, investment, trade, monetary, and labor), fiscal health scores range from 0.0 (Republic of Congo, Egypt, and Gambia) to 99.3 in Afghanistan, and a tax burden of spread of 46.1 in Chad to 96.3 in Timor-Leste. Furthermore, low judicial effectiveness goes from 12.3 in Bolivia to 52.1 in Tajikistan; and property rights (7.6 in Venezuela to 59.2 in Tonga) seem  to work in tandem with government integrity score spanning 7.9 (Venezuela) to 41.2 in The Gambia.

Income tax rate percentages are spread at spread from 13.0% in Belarus, Tajikistan, and Bolivia; corporate tax rate percentages range from 7.5 to 50 with sixteen nations at 25.0 and 22 nations at 30.0. Inflation rates range from -0.9 deflation in Chad to 1087.5 in Venezuela with unemployment rates spread out across the spectrum starting at 0.2 in Cambodia to 25.0 in Mozambique.


<br>
<br>


**Large Countries - Lower Tier - Emerging Economies (Hierarchical Cluster 3 in alphabetical order)**

<br>
<br>

China is the world's largest country populationwise at 1.4 billion followed by India with 1.3 billion and the U.S.A. at 331 million according to the uly 2021 estimates published by the U.S. Census Bureau. These three countries also have the largest (U.S.A), second largest (China), and fifth largest (India) economies in the world as measured by GDP. 

They are in a category of their own as other nations with large populations do not have comparable economy sizes. Futhermore, other nations with large economies (though not comparably so) do not have large population sizes.
<br>
<br>

**===============================================================================================================**
<br>
<br>

There are a large number of correlated variables, such as the aggregate, '2019_Score' and the different components of that score, additionally the population size with GDP. 
<br>
<br>

Assuming a meticulous method executed by the Heritage Foundation, it is observed that increases in business freedom, fiscal freedom, trade freedom, and property rights have the greatest effect on increasing the GDP per capita PPP for a given country; whereas investment freedom, monetary freedom, and government spending decrease the GDP per capita PPP (a high score in government spending corresponds to low actual spending). The government spending relationship can be explained by the definition of GDP which in of itself can be a problematic economic measure as described at this link: https://www.economist.com/briefing/2016/04/30/the-trouble-with-gdp.

<br>
<br>

Finally, there are some other shortcomings to this particular Index because it does not take into account the vast untapped valuable mineral resources of many countries in Sub-Saharan Africa, South America, and Asia. Additionally, the stable informal entrepreneural sectors of many developing nations is not taken into account, nor are the substantial raw material resources that supply lucrative industries such as gemstones (jewelry), cocoa (chocolate), coltan (cell phones and computers), uranium (nuclear industry) etc.
"""